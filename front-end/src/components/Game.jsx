import { Link } from "react-router-dom";
import { useState, useRef } from 'react';
import Information from './Game/Information';
import Choices from './Game/Choices';
import GoogleAd from './GoogleAd';

import world from '../scripts/story';
import SaveData from '../scripts/saveData';
import '../styles/play.css';

let gameSave = new SaveData('auto-save', world);
let startingPosition = world.position.location;

function wipeSave() {
  gameSave = null;
  localStorage.removeItem('auto-save');
  // This is a hacky way of setting the world back to it's default state.
  // Should this be a method within world instead?
  world.position.location = startingPosition;
  world.inventoryItems = ["axe"];
  world.locations = [startingPosition];
  world.selected.location = startingPosition;
  world.signals = [];
}

function Game() {
    localStorage.removeItem('auto-save');

  if (gameSave === null) {
    gameSave = new SaveData('auto-save', world);
  }

  /*
    Uses useRef instead of useState, this way world can keeps its methods
    I was having issues with methods being wiped when the state would be serialized
    It might be worth it to refactor how state is handled, and separate logic from it.
    Potentially, state could exist as a single room generated by world.
  */
  const worldRef = useRef(world);
  const [, forceRender] = useState({});

  const handleChange = (type, value) => {
    const w = worldRef.current;

    // am I understanding best practice? this feels hacky.
    // maybe I should have had a handleChange or handleClick function within each component.
    // will change if time allows.
    
    if (type == "option") {
      w.choosePath(value);
    }

    if (type == "location") {
      w.moveTo(value);
    }

    if (type == "item") {
      w.inspectItem(value);
      w.selectedItem = value;
    }
    
    gameSave.update(w);
    forceRender({});
  }

  const playerHasItems = (itemKeys) => { // wrapper for world.playerHasItems(). Without this transfers the function but not the inventory information, so it would break.
    return worldRef.current.playerHasItems(itemKeys);
  }
    const playerHasSignals = (signal) => { // <- ^ this seems hacky, should the paths themselves carry these methods? that way they can all be passed?
    return worldRef.current.playerHasSignals(signal);
  }

  // let world = worldRef.current;

  return (
    <div id="playScreen">
      <h1><Link id="backToTitle" to='/'>Old Cove</Link></h1>
      <Information world={worldRef.current} handleChange={handleChange}/>
      <Choices paths={worldRef.current.getPaths()} items={worldRef.current.items} lastPosition={worldRef.current.position.lastLocation} playerHasItems={playerHasItems} playerHasSignals={playerHasSignals} handleChange={handleChange}/>
      {/* <GoogleAd/> */}
    </div>
  )
}

export default Game;
export { wipeSave };