import { Link } from "react-router-dom";
import { useState, useRef } from 'react';
import Information from './Information';
import Options from './Options';
import world from '../scripts/story';
import '../styles/play.css';

function Game() {

  /*
    Uses useRef instead of useState, this way world can keeps its methods
    I was having issues with methods being wiped when the state would be serialized
    It might be worth it to refactor how state is handled, and separate logic from it.
    Potentially, state could exist as a single room generated by world.
  */
  const worldRef = useRef(world);
  const [, forceRender] = useState({});

  const handleChange = (type, value) => {
    const w = worldRef.current;

    // am I understanding best practice? this feels hacky.
    // maybe I should have had a handleChange or handleClick function within each component.
    // will change if time allows.
    
    if (type == "option") {
      w.choosePath(value);
    }

    if (type == "location") {
      w.moveTo(value);
    }

    if (type == "item") {
      w.showItemParagraphs(value);
    }
    
    forceRender({});
  }

  const playerHasItems = (itemKeys) => { // wrapper for world.playerHasItems(). Without this transfers the function but not the inventory information, so it would break.
    return worldRef.current.playerHasItems(itemKeys);
  }

  // let world = worldRef.current;

  return (
    <div id="playScreen">
      <h1><Link id="backToTitle" to='/'>Old Cove</Link></h1>
      <Information world={worldRef.current} handleChange={handleChange}/>
      <Options paths={worldRef.current.getPaths()} items={worldRef.current.items} playerHasItems={playerHasItems} handleChange={handleChange}/>
    </div>
  )
}

export default Game;